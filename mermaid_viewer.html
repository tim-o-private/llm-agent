<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Patterns - Mermaid Diagrams</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            securityLevel: 'loose',
            flowchart: { useMaxWidth: false }
        });
    </script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            border-bottom: 2px solid #eaecef;
            padding-bottom: 10px;
        }
        h2 {
            margin-top: 30px;
            border-bottom: 1px solid #eaecef;
            padding-bottom: 5px;
        }
        h3 {
            margin-top: 25px;
        }
        pre {
            background-color: #f6f8fa;
            border-radius: 3px;
            padding: 16px;
            overflow: auto;
        }
        code {
            font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
            background-color: rgba(27, 31, 35, 0.05);
            border-radius: 3px;
            padding: 0.2em 0.4em;
        }
        .mermaid {
            margin: 20px 0;
            text-align: center;
        }
        .diagram-container {
            margin: 30px 0;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .diagram-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <h1>System Patterns</h1>
    <p>This document outlines the system architecture, key technical decisions, design patterns, component relationships, and critical implementation paths of the Local LLM Terminal Environment.</p>

    <h2>System Architecture</h2>
    <p>The system follows a modular architecture with clear separation of concerns:</p>
    
    <div class="diagram-container">
        <div class="diagram-title">System Architecture Diagram</div>
        <div class="mermaid">
graph TD
    CLI[CLI Layer] --> Core[Core Layer]
    CLI --> Utils[Utilities Layer]
    Core --> Utils
    
    subgraph "CLI Layer (src/cli/)"
        main.py[main.py - Entry Point]
    end
    
    subgraph "Core Layer (src/core/)"
        context_manager[ContextManager]
        llm_interface[LLMInterface]
        file_parser[File Parser]
        agent_loader[Agent Loader]
    end
    
    subgraph "Utilities Layer (src/utils/)"
        config_loader[ConfigLoader]
        chat_helpers[Chat Helpers]
        path_helpers[Path Helpers]
    end
        </div>
    </div>

    <h3>Directory Structure</h3>
    <pre>
/
├── config/                  # Static configuration
│   ├── settings.yaml        # Global settings
│   └── agents/              # Agent-specific configurations
│       └── &lt;agent_name&gt;/    # Per-agent configuration
│           ├── agent_config.yaml  # Agent configuration
│           └── system_prompt.md   # Agent system prompt
├── data/                    # Dynamic runtime data
│   ├── global_context/      # Global context files
│   └── agents/              # Agent-specific data
│       └── &lt;agent_name&gt;/    # Per-agent data
│           ├── memory/      # Conversation memory
│           └── output/      # Agent output files
├── src/                     # Source code
│   ├── cli/                 # Command-line interface
│   ├── core/                # Core functionality
│   └── utils/               # Utility functions
└── tests/                   # Test files
    </pre>

    <h2>Key Technical Decisions</h2>
    <ol>
        <li><strong>Modular Code Organization</strong>
            <ul>
                <li>Clear separation between CLI, core functionality, and utilities</li>
                <li>Each module has a single responsibility</li>
                <li>Path construction logic centralized in path_helpers.py</li>
                <li>Agent loading logic centralized in agent_loader.py</li>
                <li>Chat helper functions centralized in chat_helpers.py</li>
            </ul>
        </li>
        <li><strong>Configuration Management</strong>
            <ul>
                <li>YAML-based configuration with environment variable overrides</li>
                <li>Separation of static configuration (config/) from dynamic data (data/)</li>
                <li>ConfigLoader class provides a unified interface for accessing configuration</li>
                <li>Configuration passed via context rather than global variables</li>
            </ul>
        </li>
        <li><strong>LLM Integration</strong>
            <ul>
                <li>LangChain framework for LLM interaction</li>
                <li>Google Gemini as the initial LLM provider</li>
                <li>LLMInterface class encapsulates LLM communication</li>
                <li>AgentExecutor pattern for tool-enabled interactions</li>
            </ul>
        </li>
        <li><strong>Memory Management</strong>
            <ul>
                <li>Per-agent conversation memory</li>
                <li>JSON-based persistence of conversation history</li>
                <li>Memory loaded on agent initialization and saved on exit/switch</li>
                <li>Session summaries generated and saved for context continuity</li>
            </ul>
        </li>
        <li><strong>Tool Integration</strong>
            <ul>
                <li>LangChain's FileManagementToolkit for file operations</li>
                <li>Sandboxed file access (agents can only access their own directories)</li>
                <li>Read-only access to configuration files</li>
                <li>Read-write access to agent data directories</li>
            </ul>
        </li>
    </ol>

    <h2>Design Patterns</h2>
    <ol>
        <li><strong>Dependency Injection</strong>
            <ul>
                <li>ConfigLoader passed to components that need it</li>
                <li>No global variables for better testability and maintainability</li>
                <li>Click context used to pass configuration through CLI commands</li>
            </ul>
        </li>
        <li><strong>Factory Pattern</strong>
            <ul>
                <li><code>load_agent_executor</code> function creates and configures AgentExecutor instances</li>
                <li><code>load_tools</code> function creates tool instances based on configuration</li>
            </ul>
        </li>
        <li><strong>Strategy Pattern</strong>
            <ul>
                <li>Different agents can be loaded with different configurations</li>
                <li>Tools are loaded based on agent configuration</li>
            </ul>
        </li>
        <li><strong>Command Pattern</strong>
            <ul>
                <li>CLI commands implemented using Click</li>
                <li>Each command is a separate function with its own options</li>
            </ul>
        </li>
        <li><strong>Repository Pattern</strong>
            <ul>
                <li>ContextManager acts as a repository for context data</li>
                <li>Abstracts the details of where and how context is stored</li>
            </ul>
        </li>
        <li><strong>Facade Pattern</strong>
            <ul>
                <li>LLMInterface provides a simplified interface to the LangChain framework</li>
                <li>Hides the complexity of LLM communication</li>
            </ul>
        </li>
    </ol>

    <h2>Component Relationships</h2>
    
    <div class="diagram-container">
        <div class="diagram-title">Component Relationships Diagram</div>
        <div class="mermaid">
graph TD
    CLI[CLI] --> AgentLoader[Agent Loader]
    CLI --> ChatHelpers[Chat Helpers]
    AgentLoader --> ContextManager[Context Manager]
    AgentLoader --> LLMInterface[LLM Interface]
    AgentLoader --> PathHelpers[Path Helpers]
    ChatHelpers --> PathHelpers
    ContextManager --> FileParser[File Parser]
    ContextManager --> ConfigLoader[Config Loader]
    LLMInterface --> ConfigLoader
    PathHelpers --> ConfigLoader
        </div>
    </div>

    <h3>Key Component Responsibilities</h3>
    <ol>
        <li><strong>ConfigLoader</strong>
            <ul>
                <li>Loads configuration from YAML files and environment variables</li>
                <li>Provides access to configuration values via dot notation</li>
            </ul>
        </li>
        <li><strong>ContextManager</strong>
            <ul>
                <li>Loads and formats context from global context directory</li>
                <li>Formats context data into structured strings for LLM consumption</li>
            </ul>
        </li>
        <li><strong>LLMInterface</strong>
            <ul>
                <li>Initializes and configures the LLM</li>
                <li>Provides methods for generating text responses</li>
            </ul>
        </li>
        <li><strong>AgentLoader</strong>
            <ul>
                <li>Loads agent configuration</li>
                <li>Creates and configures AgentExecutor instances</li>
                <li>Loads tools based on agent configuration</li>
            </ul>
        </li>
        <li><strong>ChatHelpers</strong>
            <ul>
                <li>Manages conversation memory</li>
                <li>Processes user commands</li>
                <li>Generates and saves session summaries</li>
            </ul>
        </li>
        <li><strong>PathHelpers</strong>
            <ul>
                <li>Provides standardized path construction functions</li>
                <li>Ensures consistent directory structure access</li>
            </ul>
        </li>
        <li><strong>FileParser</strong>
            <ul>
                <li>Reads and parses Markdown and YAML files</li>
                <li>Handles file-related errors</li>
            </ul>
        </li>
    </ol>

    <h2>Critical Implementation Paths</h2>

    <h3>1. CLI Initialization</h3>
    <div class="diagram-container">
        <div class="diagram-title">CLI Initialization Sequence</div>
        <div class="mermaid">
sequenceDiagram
    participant User
    participant CLI
    participant ConfigLoader
    
    User->>CLI: Run command
    CLI->>ConfigLoader: Create instance
    ConfigLoader->>ConfigLoader: Load settings.yaml
    ConfigLoader->>ConfigLoader: Load .env
    CLI->>CLI: Set log level
    CLI->>CLI: Store ConfigLoader in context
        </div>
    </div>

    <h3>2. Agent Loading</h3>
    <div class="diagram-container">
        <div class="diagram-title">Agent Loading Sequence</div>
        <div class="mermaid">
sequenceDiagram
    participant CLI
    participant AgentLoader
    participant ConfigLoader
    participant ContextManager
    participant LLM
    
    CLI->>AgentLoader: load_agent_executor(agent_name, config_loader)
    AgentLoader->>PathHelpers: Get agent config path
    AgentLoader->>AgentLoader: Load agent_config.yaml
    AgentLoader->>AgentLoader: Configure LLM
    AgentLoader->>AgentLoader: load_tools(tool_names, agent_name)
    AgentLoader->>ContextManager: get_context(None)
    ContextManager->>ContextManager: Load global context
    ContextManager-->>AgentLoader: Return formatted context
    AgentLoader->>AgentLoader: Format agent config as context
    AgentLoader->>AgentLoader: Load system prompt
    AgentLoader->>AgentLoader: Combine contexts
    AgentLoader->>AgentLoader: Create prompt template
    AgentLoader->>AgentLoader: Create tool-calling agent
    AgentLoader->>AgentLoader: Create AgentExecutor
    AgentLoader-->>CLI: Return AgentExecutor
        </div>
    </div>

    <h3>3. Chat Session Flow</h3>
    <div class="diagram-container">
        <div class="diagram-title">Chat Session Flow Sequence</div>
        <div class="mermaid">
sequenceDiagram
    participant User
    participant CLI
    participant ChatHelpers
    participant AgentExecutor
    participant Memory
    
    User->>CLI: Start chat
    CLI->>ChatHelpers: get_or_create_memory(agent_name)
    ChatHelpers->>ChatHelpers: Check if memory exists in memory dict
    ChatHelpers->>ChatHelpers: If not, load from file or create new
    ChatHelpers-->>CLI: Return memory
    CLI->>AgentLoader: load_agent_executor(agent_name)
    AgentLoader-->>CLI: Return executor
    
    loop Chat Loop
        User->>CLI: Enter input
        CLI->>ChatHelpers: process_user_command(input, agent, memory)
        alt Command: /exit
            ChatHelpers-->>CLI: Signal exit
        else Command: /agent
            ChatHelpers->>ChatHelpers: Save current memory
            ChatHelpers->>ChatHelpers: Load new memory
            ChatHelpers->>AgentLoader: Load new agent
            ChatHelpers-->>CLI: Return new agent and memory
        else Command: /summarize
            ChatHelpers->>AgentExecutor: Generate summary
            ChatHelpers->>ChatHelpers: Save summary to file
            ChatHelpers-->>CLI: Return summary
        else Regular input
            ChatHelpers->>Memory: Load memory variables
            ChatHelpers->>AgentExecutor: Invoke with input and history
            AgentExecutor-->>ChatHelpers: Return response
            ChatHelpers->>Memory: Save context
            ChatHelpers-->>CLI: Display output
        end
    end
    
    CLI->>ChatHelpers: generate_and_save_summary()
    CLI->>ChatHelpers: save_agent_memory() for all agents
        </div>
    </div>

    <h3>4. Tool Usage Flow</h3>
    <div class="diagram-container">
        <div class="diagram-title">Tool Usage Flow Sequence</div>
        <div class="mermaid">
sequenceDiagram
    participant User
    participant CLI
    participant AgentExecutor
    participant Tool
    participant FileSystem
    
    User->>CLI: Enter input requiring tool
    CLI->>AgentExecutor: Invoke with input
    AgentExecutor->>AgentExecutor: Parse input
    AgentExecutor->>AgentExecutor: Decide to use tool
    AgentExecutor->>Tool: Call tool with arguments
    
    alt File Management Tool
        Tool->>FileSystem: Read/write file in agent data dir
        FileSystem-->>Tool: Return result
    else Read Config Tool
        Tool->>FileSystem: Read file in agent config dir
        FileSystem-->>Tool: Return result
    end
    
    Tool-->>AgentExecutor: Return tool result
    AgentExecutor->>AgentExecutor: Generate response with tool result
    AgentExecutor-->>CLI: Return final response
    CLI->>User: Display response
        </div>
    </div>

    <h2>Implementation Notes</h2>
    <ol>
        <li><strong>Memory Persistence</strong>
            <ul>
                <li>Conversation history is saved as JSON files</li>
                <li>Each agent has its own memory file</li>
                <li>Memory is loaded on agent initialization</li>
                <li>Memory is saved on agent switch and application exit</li>
            </ul>
        </li>
        <li><strong>Context Loading</strong>
            <ul>
                <li>Global context is loaded from data/global_context/</li>
                <li>Agent configuration is loaded from config/agents/&lt;agent_name&gt;/</li>
                <li>System prompt is loaded from config/agents/&lt;agent_name&gt;/system_prompt.md</li>
                <li>Agent-specific data is stored in data/agents/&lt;agent_name&gt;/</li>
            </ul>
        </li>
        <li><strong>Tool Sandboxing</strong>
            <ul>
                <li>Agents can only read files from their config directory</li>
                <li>Agents can read and write files in their data directory</li>
                <li>This prevents agents from accessing files outside their scope</li>
            </ul>
        </li>
        <li><strong>Error Handling</strong>
            <ul>
                <li>Comprehensive error handling for file operations</li>
                <li>Graceful degradation when files are missing</li>
                <li>Detailed logging for debugging</li>
            </ul>
        </li>
        <li><strong>Configuration Flexibility</strong>
            <ul>
                <li>Configuration can be overridden via environment variables</li>
                <li>Default values are provided for missing configuration</li>
                <li>Agent-specific configuration can override global settings</li>
            </ul>
        </li>
    </ol>
</body>
</html>
