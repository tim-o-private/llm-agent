# Plan: Refactor Agent Executor Caching and Client Session Management

**Task:** Refactor Agent Executor Caching and Client Session Management using `chat_sessions` Table.

## 1. Requirements Analysis (Aligned with Final DDL and Concepts):

*   **R1 (Executor Cache):** Server caches one `AgentExecutor` per `(user_id, agent_name)`. The `agent_name` refers to the type of executor being used for the chat.
*   **R2 (Executor Liveness):** The `AgentExecutor` for `(user_id, agent_name)` is kept in the server cache if any row in `public.chat_sessions` for that `(user_id, agent_name)` has `is_active = true` and its `updated_at` timestamp is within a defined keep-alive window.
*   **R3 (Client DB Interaction):** Client-side logic is solely responsible for managing rows in `public.chat_sessions` (creating new session instance records, setting their `is_active` status, updating `updated_at`) via Supabase client hooks.
*   **R4 (No New Server Endpoints):** No new server API endpoints for session management beyond the existing `/api/chat`.
*   **R5 (Chat Session Table - `chat_sessions`):
    *   `id` (UUID PK): Identifier for a specific client session instance/activity record.
    *   `chat_id` (UUID, nullable): Identifier for the persistent chat conversation thread's message history. This ID should be consistent for all `chat_sessions` rows that are part of the same long-running conversation for a given `(user_id, agent_name)`.
    *   `user_id`, `agent_name`, `is_active`, `updated_at`, `created_at`, `metadata`.
*   **R6 (Minimal Server API Changes):** `/api/chat` endpoint changes are minimal.

## 2. Components Affected:

*   **Database:** New `public.chat_sessions` table. Old `user_agent_active_sessions` table to be deprecated/removed.
*   **Server-Side (`chatServer/main.py`):** `AGENT_EXECUTOR_CACHE` logic; scheduled task for executor eviction; `/api/chat` adaptation.
*   **Client-Side (`webApp/`):** `stores/useChatStore.ts`; `api/hooks/useChatSessionHooks.ts` (adapted); `components/ChatPanel.tsx`.

## 3. Architecture Considerations:

*   **Persistent Chat ID (`chat_sessions.chat_id`):
    *   **Strategy:** On initializing for an `agent_name`:
        1.  Client queries `public.chat_sessions` for `(user_id, agent_name)`: `SELECT chat_id FROM public.chat_sessions WHERE user_id = $1 AND agent_name = $2 AND chat_id IS NOT NULL ORDER BY created_at DESC LIMIT 1;`
        2.  If a `chat_id` is found, it's reused.
        3.  If no `chat_id` is found (first-time interaction for this `user_id, agent_name` pair), a new `UUID` is generated by the client to serve as this persistent `chat_id`.
        4.  This determined/newly-generated `chat_id` is then used when creating a new `chat_sessions` row for the current client session activity.
*   **Client Session Instance Record (`chat_sessions.id`):** Each time `ChatPanel` initializes for a persistent conversation (identified by `chat_sessions.chat_id`), it creates a *new row* in `chat_sessions` with a new unique `chat_sessions.id` (PK). This new row's `chat_id` column is populated with the persistent conversation ID. This row's `is_active` flag and `updated_at` timestamp track the current tab's/client's activity.
*   **Server Executor Eviction:** Background/scheduled task on server.

## 4. Implementation Strategy (Phased):

*   **Phase 0: Database Setup**
    *   [X] `public.chat_sessions` table created by user.
    *   [ ] **Action:** Remove the old `user_agent_active_sessions` table from the database.
*   **Phase 1: Client-Side - Managing `chat_id` (Persistent Chat ID) and `chat_sessions.id` (Session Instance ID)**
    *   **P1.1: Adapt/Refactor Supabase Client Hooks in `webApp/src/api/hooks/useChatSessionHooks.ts`:**
        *   Rename `UserAgentActiveSession` interface to `ActiveChatSession` (maps to a row in `chat_sessions`).
        *   Adapt `useFetchActiveChatSession` to `useFetchLatestChatId(userId, agentName)` (gets `chat_id` for the conversation thread).
        *   Adapt `useUpsertActiveChatSession` for `chat_sessions.id` rows.
            *   Create mode input: `{ chatId: string, userId: string, agentName: string }` -> `INSERT INTO public.chat_sessions (user_id, agent_name, chat_id, is_active, updated_at, created_at) VALUES ($1, $2, $3, true, now(), now()) RETURNING id, chat_id;`
            *   Update mode input: `{ sessionId: string, isActive: boolean, userId: string }` -> `UPDATE public.chat_sessions SET is_active = $1, updated_at = now() WHERE id = $2 AND user_id = $3 RETURNING id, chat_id, is_active, updated_at;`
    *   **P1.2: Refactor `webApp/src/stores/useChatStore.ts`:**
        *   State: `activeChatId: string | null` (stores `chat_sessions.chat_id`), `currentSessionId: string | null` (stores `chat_sessions.id`).
        *   `initializeSessionAsync(agentName)`:
            1.  Call `useFetchLatestChatId` to get/determine `pChatId`.
            2.  If `pChatId` is null, generate `pChatId = uuidv4()`.
            3.  Set `activeChatId` in store to `pChatId`.
            4.  Call `useManageChatsession` (create mode) with `pChatId, userId, agentName`. Get `sessionId`.
            5.  Set `currentSessionId` in store.
            6.  (Optional) `localStorage` can cache these IDs for the current tab.
        *   `addMessage`: If `currentSessionId` exists, call `useManageChatsession` (update mode) for heartbeat.
        *   `clearCurrentSession()`: If `currentSessionId` exists, call `useManageChatsession` (update mode, `isActive: false`). Clear local store state.
    *   **P1.3: Update `webApp/src/components/ChatPanel.tsx`:**
        *   On mount/`agentName` change: Trigger `initializeSessionAsync(agentName)`.
        *   `fetchAiResponse` sends `activeChatId` from store as `session_id` in JSON body to `/api/chat`.
        *   Implement periodic "heartbeat" using `useManageChatsession` (update mode).
        *   Implement "best-effort" `beforeunload` listener using `useManageChatsession` (update mode, `isActive: false`).
*   **Phase 2: Server-Side Executor Cache Logic (`chatServer/main.py`)**
    *   **P2.1:** `AGENT_EXECUTOR_CACHE` Key: `(user_id, agent_name)`. Type: `Dict` or `cachetools.Cache` (no self-TTL).
    *   **P2.2:** `/api/chat` endpoint:
        *   Receives `chat_input.agent_id` (as `agent_name`) and `chat_input.session_id` (as `chat_sessions.chat_id`).
        *   Uses `(user_id, chat_input.agent_id)` for `AGENT_EXECUTOR_CACHE` key.
        *   `PostgresChatMessageHistory` uses `chat_input.session_id` (the `chat_sessions.chat_id`).
        *   Does NOT write to `chat_sessions` table.
    *   **P2.3:** Implement Server-Side Scheduled Task (e.g., `asyncio.create_task` in FastAPI `lifespan`):
        *   `deactivate_stale_chat_session_instances()`: `UPDATE public.chat_sessions SET is_active = false WHERE is_active = true AND now() - updated_at > INTERVAL 'Y minutes';` (Y = `CHAT_SESSION_INTERACTION_TTL`, e.g., 30 mins).
        *   `evict_inactive_executors()`: Iterates `AGENT_EXECUTOR_CACHE`. For each `(user_id, agent_name)`, if `SELECT 1 FROM public.chat_sessions WHERE user_id = %s AND agent_name = %s AND is_active = true AND now() - updated_at < INTERVAL 'X minutes' LIMIT 1;` (X = `EXECUTOR_KEEPALIVE_WINDOW`, e.g., 35-40 mins) returns no rows, evict executor.
        *   Schedule these tasks to run periodically.

## 5. Detailed Steps (High-Level):
*   **DB Admin:**
    *   [ ] Delete `user_agent_active_sessions` table.
*   **Client (`webApp/`):**
    1.  [ ] Adapt/Refactor React Query hooks for `chat_sessions` table (P1.1).
    2.  [ ] Refactor `useChatStore.ts` per P1.2.
    3.  [ ] Update `ChatPanel.tsx` per P1.3.
*   **Server (`chatServer/main.py`):**
    1.  [ ] Update `AGENT_EXECUTOR_CACHE` keying (P2.1).
    2.  [ ] Adjust `/api/chat` endpoint per P2.2.
    3.  [ ] Implement and schedule background tasks per P2.3.

## 6. Dependencies & Coordination:
*   Client correctly manages `chat_id` and `id` in `chat_sessions`.
*   Server eviction logic relies on `is_active` and `updated_at` in `chat_sessions`.

## 7. Challenges & Mitigations:
*   **Determining Persistent `chat_id`:** Robust client logic for P1.2.1-P1.2.3 is key.
*   **Client Heartbeat/`beforeunload` Reliability:** Server's scheduled tasks are the fallback.
*   **Server-Side Task Implementation:** Choose appropriate scheduling method (FastAPI lifespan `asyncio.create_task` for initial simplicity). 